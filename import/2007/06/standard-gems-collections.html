<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.gemfix.com/images/stones/garnet_green/demantoid_18.jpg"><img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer; width: 155px; height: 156px;" src="http://www.gemfix.com/images/stones/garnet_green/demantoid_18.jpg" alt="" border="0" /></a>This until-recently-lonely module only houses two alternative collection types, deque and defaultdict, but promises useful things today and more to come. Anytime we have a good place to put things, we find more things to put there. With the new defaultdict type, collections is finally more than just that thing you use to get a deque: its a full fledged utility library. More optimized collection types (chains, B-Trees, and bags, anyone?) are sure to come, so keep your eye here every new Python release changelog, and maybe you'll get an early Christmas present.<br /><br /><script type="text/javascript"><!-- google_ad_client = "pub-7984816525584511"; google_ad_width = 728; google_ad_height = 90; google_ad_format = "728x90_as"; google_ad_type = "text_image"; //2007-05-01: Ranting Techno Rave RSS google_ad_channel = "2656351264"; //--><br /></script>Here is a quick rundown of what is offered today, using possibly silly examples.<br /><br /><pre>d = deque()<br />d.extend(xrange(10))<br />while d:<br />  print d.popleft()</pre><br />What you see here is that deque acts like a list but has mirror versions of many end-modifying operations, like append, extend, and pop, which operate on the 'left' side. A list is far less efficient with insertion and popping from anywhere but the end of the list. This makes deque great for First-In-First-Out structures, where a list is more suited for a First-In-Last-Out setup.<br /><br /><pre>dd = collections.defaultdict(lambda: None)<br />dd['a'] = 1<br />dd['b'] = 2<br />print dd['c'] or 3</pre><br />Here we automatically handle a non-existant key with a default value, None. A factory callable is used, so that we can actually return different values, but we don't get the key. One interesting use is itertools.count().next as the factory, which means every missing key is automatically filled with an automatically incrementing integer.<br /><br /><script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"><br /></script>