Discussions and my first PEP will hopefully lead to "fixing" super in 3.0 and could probably also be backported to 2.x branches. The two threads are linked here, and I'm going to include the reference implementation so anyone can check it out and comment on the design.<br /><ul><li><a href="http://mail.python.org/pipermail/python-3000/2007-April/006667.html">http://mail.python.org/pipermail/python-3000/2007-April/006667.html</a></li><li><a href="http://mail.python.org/pipermail/python-dev/2007-April/072807.html">http://mail.python.org/pipermail/python-dev/2007-April/072807.html</a></li></ul><br /><pre><br />     #!/usr/bin/env python<br />     #<br />     # newsuper.py<br /><br />     import sys<br /><br />     class SuperMetaclass(type):<br />         def __getattr__(cls, attr):<br />             calling_frame = sys._getframe().f_back<br />             instance_name = calling_frame.f_code.co_varnames[0]<br />             instance = calling_frame.f_locals[instance_name]<br />             return getattr(instance.__super__, attr)<br /><br />     class Super(object):<br />         __metaclass__ = SuperMetaclass<br />         def __init__(self, type, obj=None):<br />             if isinstance(obj, Super):<br />                 obj = obj.__obj__<br />             self.__type__ = type<br />             self.__obj__ = obj<br />         def __get__(self, obj, cls=None):<br />             if obj is None:<br />                 raise Exception('only supports instances')<br />             else:<br />                 return Super(self.__type__, obj)<br />         def __getattr__(self, attr):<br />             mro = iter(self.__obj__.__class__.__mro__)<br />             for cls in mro:<br />                 if cls is self.__type__:<br />                     break<br />             for cls in mro:<br />                 if attr in cls.__dict__:<br />                     x = cls.__dict__[attr]<br />                     if hasattr(x, '__get__'):<br />                         x = x.__get__(self, cls)<br />                     return x<br />             raise AttributeError, attr<br /><br />     class autosuper(type):<br />         def __init__(cls, name, bases, clsdict):<br />             cls.__super__ = Super(cls)<br /><br />     if __name__ == '__main__':<br />         class A(object):<br />             __metaclass__ = autosuper<br />             def f(self):<br />                 return 'A'<br /><br />         class B(A):<br />             def f(self):<br />                 return 'B' + Super.f()<br /><br />         class C(A):<br />             def f(self):<br />                 return 'C' + Super.f()<br /><br />         class D(B, C):<br />             def f(self, arg=None):<br />                 var = None<br />                 return 'D' + Super.f()<br /><br />         assert D().f() == 'DBCA'<br /></pre><br /><br />What do you think?