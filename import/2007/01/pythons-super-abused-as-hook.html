There has been some recent-ish discussion on the python-dev mailing list about "fixing" the <span style="font-family:courier new;">super</span> built-in, which is used to access attributes of an object with lookup rules on the superclass of a given class. This is used for different things and in different ways, but the most common usage seems to be as follows:<br /><br /><pre>class Foo(Bar):<br />   def action(self):<br />       super(Foo, self).action()<br />       self.actionCalledOnFooInstance = True</pre><br />This causes a call to <span style="font-family:courier new;">Foo().action()</span> to call the action method of the next class in the Method Resolution Order. Now, <span style="font-family:courier new;">Bar.action</span> might exist, or maybe <span style="font-family:courier new;">Bar</span> inherits from <span style="font-family:courier new;">Baz</span> and <span style="font-family:courier new;">Baz.action()</span> will be called. The point is, you don't have to know. The typical pattern here is the that we are looking for the superclass of the same class we are within (<span style="font-family:courier new;">Foo</span>) and call the same method we're already in (<span style="font-family:courier new;">action</span>), which is a repetition some people want to fix.<br /><br />I propose that <span style="font-family:courier new;">super()</span> is not broken at all, or even failing, but simply that we are misusing it where anothing idiom may be more appropriate. The more appropriate idiom might be hooks. Sometimes our function using <span style="font-family:courier new;">super()</span> should actually be calling a hook and other times it should be the hook. In the example above, we want something to happen after the regular <span style="font-family:courier new;">action()</span> method is called, so we redefine the entire <span style="font-family:courier new;">action()</span> method to call the original and then execute our one little line. We require all the overhead and issues with <span style="font-family:courier new;">super()</span> largely for varients of this common use case. Instead, consider if we wrote the following:<br /><br /><pre>class Foo(Bar):<br />   def hook_after_action(self):<br />       self.actionCalledOnFooInstance = True</pre><br />Do you see how much simpler that is? The requirement here is that either <span style="font-family:courier new;">super(Foo, self).action</span> would call <span style="font-family:courier new;">hook_after_action</span> if it exists (or there could be a default no-op version) or  some mechanism outside of the <span style="font-family:courier new;">action()</span> method might handle it, perhaps wrapping it up on request or at definition. Maybe a standard hook format could even be a candidate for brining into the language.<br /><br />Hooks are very valuable concepts that are not used enough. We can save ourselves a lot of trouble by using them. There is a lot more I could say about them, but this post was mostly about their relation to the many use cases of super.<br /><br />PS - Some of this can be known to relate to the concept called "Aspect-Oriented Programm" which has very little weight in the Python world, because here its so easy to do that it doesn't deserve a name and is reduced to simply wrapping functions or having hooks.