People go through a few different stages of programming Python, and one
of the last is learning to optimize well and without sacrificing the
quality of the code. When a piece of code is bottlenecking, it comes
time to look at how you can really turn a turtle into a hare. Or, should
that be the other way around?
I want to showcase ways this transformation is possible so I'm going to
make a call for anyone to submit code that needs optimized. The next
post in this series will show how the code was optimized, what
techniques might have been tried and would have failed, and maybe some
tips about why the changes worked. There will also be a sample of
unoptimized code at the end, with the challenge for improvements to be
sent in. From there, if the series has interest, it will continue and
maybe evolve.
Send in samples of code you think could be faster. They can be real
world or fake, as long as they are realistic. It doesn't matter how
poorly written they are, but we need to know what it does. It needs to
actually work. The best submissions will be a single function and a
docstring that tells me what it can be called with and what it should be
expected to do. Things that can unittest well and don't rely on things
from the outside are best.
So, impress me, everyone, with the worst code you've got.
