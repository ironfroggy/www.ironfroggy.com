An explaination of the virtues of <span style="font-family: courier new">foo is not None</span> over <span style="font-family: courier new">foo != None</span> lead to an explaination of identity comparison with the <span style="font-family: courier new">is</span> operator. A fellow equated this to, roughly, <span style="font-family: courier new">id(a.x) == id(b.x)</span>, which I told him was roughly correct but probably not actually correct. It only took a little bit of through to see how uncorrect it was.<br /><br />The following code creates a simple class with one property descriptor (read-only). It solves the requirements that with to instances of this class, a and b, <span style="font-family: courier new">id(a.x)==id(b.x)</span> can be true while <span style="font-family: courier new">a.x is not b.x</span>! How does this happen?<br /><br /><pre>class foo(object):<br />  x = property(lambda s: id(s))<br />a = foo()<br />b = foo()<br />assert id(a.x) == id(b.x)<br />assert a.x is not b.x<br /></pre><br />How on earth does this code prove what it does? <span style="font-family: courier new">a.x</span> and <span style="font-family: courier new">b.x</span> are created on the fly, passed to the <span style="font-family: courier new">id</span> function, and then destroyed with no references left. Because they are both created in the right order with the <span style="font-family: courier new">id(a.x)==id(b.x)</span> expression, they just happen to get the same memory addresses, which in CPython is used for the <span style="font-family: courier new">id</span> function's result. This leads to misleading results, so don't rely on them in such ways. Identification is what it is, and you shouldn't try to break it down.